import {
  _Î£,
  html,
  noChange,
  nothing,
  render,
  svg
} from "./chunk-FVDTQV3F.js";
import "./chunk-VK5M77CT.js";

// node_modules/@lit/reactive-element/development/css-tag.js
var supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var constructionToken = Symbol();
var CSSResult = class {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  get styleSheet() {
    if (supportsAdoptingStyleSheets && this._styleSheet === void 0) {
      this._styleSheet = new CSSStyleSheet();
      this._styleSheet.replaceSync(this.cssText);
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
};
var cssResultCache = new Map();
var getCSSResult = (cssText) => {
  let result = cssResultCache.get(cssText);
  if (result === void 0) {
    cssResultCache.set(cssText, result = new CSSResult(cssText, constructionToken));
  }
  return result;
};
var textFromCSSResult = (value) => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.`);
  }
};
var unsafeCSS = (value) => {
  return getCSSResult(typeof value === "string" ? value : String(value));
};
var css = (strings, ...values) => {
  const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return getCSSResult(cssText);
};
var adoptStyles = (renderRoot, styles) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
  } else {
    styles.forEach((s) => {
      const style = document.createElement("style");
      style.textContent = s.cssText;
      renderRoot.appendChild(style);
    });
  }
};
var cssResultFromStyleSheet = (sheet) => {
  let cssText = "";
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};
var getCompatibleStyle = supportsAdoptingStyleSheets ? (s) => s : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;

// node_modules/@lit/reactive-element/development/reactive-element.js
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var DEV_MODE = true;
var requestUpdateThenable;
if (DEV_MODE) {
  console.warn(`Running in dev mode. Do not use in production!`);
  if (((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && globalThis["reactiveElementPlatformSupport"] === void 0) {
    console.warn(`Shadow DOM is being polyfilled via ShadyDOM but the \`polyfill-support\` module has not been loaded.`);
  }
  requestUpdateThenable = {
    then: (onfulfilled, _onrejected) => {
      console.warn(`\`requestUpdate\` no longer returns a Promise.Use \`updateComplete\` instead.`);
      if (onfulfilled !== void 0) {
        onfulfilled(false);
      }
    }
  };
}
var JSCompiler_renameProperty = (prop, _obj) => prop;
var defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? "" : null;
        break;
      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;
      case Number:
        fromValue = value === null ? null : Number(value);
        break;
      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  }
};
var notEqual = (value, old) => {
  return old !== value && (old === old || value === value);
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var finalized = "finalized";
var ReactiveElement = class extends HTMLElement {
  constructor() {
    super();
    this.__instanceProperties = new Map();
    this.__pendingConnectionPromise = void 0;
    this.__enableConnection = void 0;
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this._initialize();
  }
  static addInitializer(initializer) {
    var _a3;
    (_a3 = this._initializers) !== null && _a3 !== void 0 ? _a3 : this._initializers = [];
    this._initializers.push(initializer);
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this.elementProperties.forEach((v, p) => {
      const attr = this.__attributeNameForProperty(p, v);
      if (attr !== void 0) {
        this.__attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  static createProperty(name, options = defaultPropertyDeclaration) {
    if (options.state) {
      options.attribute = false;
    }
    this.finalize();
    this.elementProperties.set(name, options);
    if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
      const key = typeof name === "symbol" ? Symbol() : `__${name}`;
      const descriptor = this.getPropertyDescriptor(name, key, options);
      if (descriptor !== void 0) {
        Object.defineProperty(this.prototype, name, descriptor);
      }
    }
  }
  static getPropertyDescriptor(name, key, options) {
    return {
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdate(name, oldValue, options);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(name) {
    return this.elementProperties.get(name) || defaultPropertyDeclaration;
  }
  static finalize() {
    if (this.hasOwnProperty(finalized)) {
      return false;
    }
    this[finalized] = true;
    const superCtor = Object.getPrototypeOf(this);
    superCtor.finalize();
    this.elementProperties = new Map(superCtor.elementProperties);
    this.__attributeToPropertyMap = new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...Object.getOwnPropertySymbols(props)
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    if (DEV_MODE) {
      const warnRemoved = (obj, name) => {
        if (obj[name] !== void 0) {
          console.warn(`\`${name}\` is implemented. It has been removed from this version of ReactiveElement. See the changelog at https://github.com/lit/lit/blob/main/packages/reactive-element/CHANGELOG.md`);
        }
      };
      [`initialize`, `requestUpdateInternal`, `_getUpdateComplete`].forEach((name) => warnRemoved(this.prototype, name));
    }
    return true;
  }
  static finalizeStyles(styles) {
    const elementStyles = [];
    if (Array.isArray(styles)) {
      const set = new Set(styles.flat(Infinity).reverse());
      for (const s of set) {
        elementStyles.unshift(getCompatibleStyle(s));
      }
    } else if (styles !== void 0) {
      elementStyles.push(getCompatibleStyle(styles));
    }
    return elementStyles;
  }
  static __attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  _initialize() {
    var _a3;
    this.__updatePromise = new Promise((res) => this.enableUpdating = res);
    this._$changedProperties = new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a3 = this.constructor._initializers) === null || _a3 === void 0 ? void 0 : _a3.forEach((i) => i(this));
  }
  addController(controller) {
    var _a3, _b3;
    ((_a3 = this.__controllers) !== null && _a3 !== void 0 ? _a3 : this.__controllers = []).push(controller);
    if (this.renderRoot !== void 0 && this.isConnected) {
      (_b3 = controller.hostConnected) === null || _b3 === void 0 ? void 0 : _b3.call(controller);
    }
  }
  removeController(controller) {
    var _a3;
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.splice(this.__controllers.indexOf(controller) >>> 0, 1);
  }
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        this.__instanceProperties.set(p, this[p]);
        delete this[p];
      }
    });
  }
  createRenderRoot() {
    var _a3;
    const renderRoot = (_a3 = this.shadowRoot) !== null && _a3 !== void 0 ? _a3 : this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  connectedCallback() {
    var _a3;
    if (this.renderRoot === void 0) {
      this.renderRoot = this.createRenderRoot();
    }
    this.enableUpdating(true);
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
      var _a4;
      return (_a4 = c.hostConnected) === null || _a4 === void 0 ? void 0 : _a4.call(c);
    });
    if (this.__enableConnection) {
      this.__enableConnection();
      this.__pendingConnectionPromise = this.__enableConnection = void 0;
    }
  }
  enableUpdating(_requestedUpdate) {
  }
  disconnectedCallback() {
    var _a3;
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
      var _a4;
      return (_a4 = c.hostDisconnected) === null || _a4 === void 0 ? void 0 : _a4.call(c);
    });
    this.__pendingConnectionPromise = new Promise((r) => this.__enableConnection = r);
  }
  attributeChangedCallback(name, _old, value) {
    this._$attributeToProperty(name, value);
  }
  __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    var _a3, _b3;
    const attr = this.constructor.__attributeNameForProperty(name, options);
    if (attr !== void 0 && options.reflect === true) {
      const toAttribute = (_b3 = (_a3 = options.converter) === null || _a3 === void 0 ? void 0 : _a3.toAttribute) !== null && _b3 !== void 0 ? _b3 : defaultConverter.toAttribute;
      const attrValue = toAttribute(value, options.type);
      if (DEV_MODE && this.constructor.enabledWarnings.indexOf("migration") >= 0 && attrValue === void 0) {
        console.warn(`The attribute value for the ${name} property is undefined. The attribute will be removed, but in the previous version of ReactiveElement, the attribute would not have changed.`);
      }
      this.__reflectingProperty = name;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  _$attributeToProperty(name, value) {
    var _a3, _b3, _c3;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name);
    if (propName !== void 0 && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter = options.converter;
      const fromAttribute = (_c3 = (_b3 = (_a3 = converter) === null || _a3 === void 0 ? void 0 : _a3.fromAttribute) !== null && _b3 !== void 0 ? _b3 : typeof converter === "function" ? converter : null) !== null && _c3 !== void 0 ? _c3 : defaultConverter.fromAttribute;
      this.__reflectingProperty = propName;
      this[propName] = fromAttribute(value, options.type);
      this.__reflectingProperty = null;
    }
  }
  requestUpdate(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      options = options || this.constructor.getPropertyOptions(name);
      const hasChanged = options.hasChanged || notEqual;
      if (hasChanged(this[name], oldValue)) {
        if (!this._$changedProperties.has(name)) {
          this._$changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && this.__reflectingProperty !== name) {
          if (this.__reflectingProperties === void 0) {
            this.__reflectingProperties = new Map();
          }
          this.__reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this.isUpdatePending && shouldRequestUpdate) {
      this.__updatePromise = this.__enqueueUpdate();
    }
    return DEV_MODE ? requestUpdateThenable : void 0;
  }
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
      while (this.__pendingConnectionPromise) {
        await this.__pendingConnectionPromise;
      }
    } catch (e) {
      Promise.reject(e);
    }
    const result = this.performUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  performUpdate() {
    var _a3;
    if (!this.isUpdatePending) {
      return;
    }
    if (!this.hasUpdated) {
      if (DEV_MODE) {
        const shadowedProperties = [];
        this.constructor.elementProperties.forEach((_v, p) => {
          var _a4;
          if (this.hasOwnProperty(p) && !((_a4 = this.__instanceProperties) === null || _a4 === void 0 ? void 0 : _a4.has(p))) {
            shadowedProperties.push(p);
          }
        });
        if (shadowedProperties.length) {
          console.warn(`The following properties will not trigger updates as expected because they are set using class fields: ${shadowedProperties.join(", ")}. Native class fields and some compiled output will overwrite accessors used for detecting changes. To fix this issue, either initialize properties in the constructor or adjust your compiler settings; for example, for TypeScript set \`useDefineForClassFields: false\` in your \`tsconfig.json\`.`);
        }
      }
    }
    if (this.__instanceProperties) {
      this.__instanceProperties.forEach((v, p) => this[p] = v);
      this.__instanceProperties = void 0;
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
          var _a4;
          return (_a4 = c.hostUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(c);
        });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  willUpdate(_changedProperties) {
  }
  _$didUpdate(changedProperties) {
    var _a3;
    (_a3 = this.__controllers) === null || _a3 === void 0 ? void 0 : _a3.forEach((c) => {
      var _a4;
      return (_a4 = c.hostUpdated) === null || _a4 === void 0 ? void 0 : _a4.call(c);
    });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
    if (DEV_MODE && this.isUpdatePending && this.constructor.enabledWarnings.indexOf("change-in-update") >= 0) {
      console.warn(`An update was requested (generally because a property was set) after an update completed, causing a new update to be scheduled. This is inefficient and should be avoided unless the next update can only be scheduled as a side effect of the previous update.`);
    }
  }
  __markUpdated() {
    this._$changedProperties = new Map();
    this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this.__updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this.__reflectingProperties !== void 0) {
      this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));
      this.__reflectingProperties = void 0;
    }
    this.__markUpdated();
  }
  updated(_changedProperties) {
  }
  firstUpdated(_changedProperties) {
  }
};
_f = finalized;
ReactiveElement[_f] = true;
ReactiveElement.elementProperties = new Map();
ReactiveElement.elementStyles = [];
ReactiveElement.shadowRootOptions = { mode: "open" };
(_c = (_b = globalThis)["reactiveElementPlatformSupport"]) === null || _c === void 0 ? void 0 : _c.call(_b, { ReactiveElement });
if (DEV_MODE) {
  ReactiveElement.enabledWarnings = ["change-in-update"];
  const ensureOwnWarnings = function(ctor) {
    if (!ctor.hasOwnProperty(JSCompiler_renameProperty("enabledWarnings", ctor))) {
      ctor.enabledWarnings = ctor.enabledWarnings.slice();
    }
  };
  ReactiveElement.enableWarning = function(warning) {
    ensureOwnWarnings(this);
    if (this.enabledWarnings.indexOf(warning) < 0) {
      this.enabledWarnings.push(warning);
    }
  };
  ReactiveElement.disableWarning = function(warning) {
    ensureOwnWarnings(this);
    const i = this.enabledWarnings.indexOf(warning);
    if (i >= 0) {
      this.enabledWarnings.splice(i, 1);
    }
  };
}
((_d = (_e = globalThis)["reactiveElementVersions"]) !== null && _d !== void 0 ? _d : _e["reactiveElementVersions"] = []).push("1.0.0-rc.2");

// node_modules/lit-element/development/lit-element.js
var _a2;
var _b2;
var _c2;
var _d2;
var _e2;
var _f2;
var UpdatingElement = ReactiveElement;
var DEV_MODE2 = true;
((_a2 = (_f2 = globalThis)["litElementVersions"]) !== null && _a2 !== void 0 ? _a2 : _f2["litElementVersions"] = []).push("3.0.0-rc.2");
var LitElement = class extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = { host: this };
    this.__childPart = void 0;
  }
  createRenderRoot() {
    var _a3;
    var _b3;
    const renderRoot = super.createRenderRoot();
    (_a3 = (_b3 = this.renderOptions).renderBefore) !== null && _a3 !== void 0 ? _a3 : _b3.renderBefore = renderRoot.firstChild;
    return renderRoot;
  }
  update(changedProperties) {
    const value = this.render();
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a3;
    super.connectedCallback();
    (_a3 = this.__childPart) === null || _a3 === void 0 ? void 0 : _a3.setConnected(true);
  }
  disconnectedCallback() {
    var _a3;
    super.disconnectedCallback();
    (_a3 = this.__childPart) === null || _a3 === void 0 ? void 0 : _a3.setConnected(false);
  }
  render() {
    return noChange;
  }
};
LitElement["finalized"] = true;
LitElement._$litElement$ = true;
(_c2 = (_b2 = globalThis)["litElementHydrateSupport"]) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, { LitElement });
(_e2 = (_d2 = globalThis)["litElementPlatformSupport"]) === null || _e2 === void 0 ? void 0 : _e2.call(_d2, { LitElement });
if (DEV_MODE2) {
  LitElement["finalize"] = function() {
    const finalized2 = ReactiveElement.finalize.call(this);
    if (!finalized2) {
      return false;
    }
    const warnRemoved = (obj, name) => {
      if (obj[name] !== void 0) {
        console.warn(`\`${name}\` is implemented. It has been removed from this version of LitElement. `);
      }
    };
    [`render`, `getStyles`].forEach((name) => warnRemoved(this, name));
    [`adoptStyles`].forEach((name) => warnRemoved(this.prototype, name));
    return true;
  };
}
var _\u03A6 = {
  _$attributeToProperty: (el, name, value) => {
    el._$attributeToProperty(name, value);
  },
  _$changedProperties: (el) => el._$changedProperties
};
export {
  CSSResult,
  LitElement,
  ReactiveElement,
  UpdatingElement,
  _\u03A3,
  _\u03A6,
  adoptStyles,
  css,
  defaultConverter,
  getCompatibleStyle,
  html,
  noChange,
  notEqual,
  nothing,
  render,
  supportsAdoptingStyleSheets,
  svg,
  unsafeCSS
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
//# sourceMappingURL=lit.js.map
